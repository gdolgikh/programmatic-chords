---
import Layout from '../components/Layout.astro';
---

<Layout title="Chord Palette - Scale-Based Chord Explorer" description="Explore chords by scale, build progressions, and generate AI backing tracks. Interactive guitar chord palette with audio playback.">

  <!-- Page Header -->
  <section class="palette-header">
    <h1>Chord <span>Palette</span></h1>
  </section>

  <!-- Scale Selector -->
  <section class="scale-selector">
    <span class="selector-label">Root Note</span>
    <div class="root-buttons" id="rootButtons"></div>
    <div class="scale-row">
      <select class="scale-select" id="scaleSelect"></select>
      <span class="scale-label" id="scaleLabel">C Major</span>
      <span class="loading-indicator" id="loadingIndicator"></span>
    </div>
  </section>

  <!-- Chord Grid -->
  <section class="grid-section">
    <div class="chord-grid" id="chordGrid"></div>
  </section>

  <!-- Chord Diagram -->
  <section class="diagram-section" id="diagramSection">
    <div class="diagram-header">
      <span class="diagram-chord-name" id="diagramName"></span>
      <span class="diagram-quality" id="diagramQuality"></span>
    </div>
    <div class="diagram-container">
      <div class="diagram-svg-wrap" id="diagramSvg"></div>
    </div>
    <div class="diagram-notes" id="diagramNotes"></div>
    <button class="add-to-progression" id="addToProgression">+ Add to Progression</button>
  </section>

  <!-- Progression Builder -->
  <section class="progression-section">
    <span class="selector-label">Progression</span>
    <div class="progression-strip empty-state" id="progressionStrip"></div>
    <div class="progression-controls">
      <button class="ctrl-btn play-btn" id="playBtn" disabled>Play</button>
      <button class="ctrl-btn stop-btn" id="stopBtn" disabled>Stop</button>
      <button class="ctrl-btn clear-btn" id="clearBtn" disabled>Clear</button>
      <div class="bpm-control">
        <span class="bpm-label" id="bpmLabel">100 bpm</span>
        <input type="range" class="bpm-slider" id="bpmSlider" min="40" max="200" value="100">
      </div>
    </div>
    <div class="progression-settings">
      <div class="setting-group">
        <span class="setting-label">Time</span>
        <select class="setting-select" id="timeSigSelect">
          <option value="4/4" selected>4/4</option>
          <option value="3/4">3/4</option>
          <option value="6/8">6/8</option>
        </select>
      </div>
      <div class="setting-group">
        <span class="setting-label">Play</span>
        <select class="setting-select" id="playTypeSelect">
          <option value="strum" selected>Strum</option>
          <option value="arpeggio">Arpeggio</option>
        </select>
      </div>
      <div class="setting-group">
        <span class="setting-label">Loop</span>
        <button class="setting-toggle" id="loopToggle">Off</button>
      </div>
      <div class="setting-group">
        <span class="setting-label">Metronome</span>
        <button class="setting-toggle" id="metronomeToggle">Off</button>
      </div>
    </div>
    <div class="generate-section" id="generateSection">
      <div class="generate-row">
        <input type="text" class="style-input" id="styleInput" placeholder="Style: acoustic folk, jazz trio, lo-fi beats...">
        <span class="setting-select" style="pointer-events:none;opacity:.7">30 sec</span>
        <button class="ctrl-btn generate-btn" id="generateBtn" disabled>Generate Track</button>
        <span class="credit-badge" id="creditBadge" style="display:none"></span>
      </div>
      <div class="buy-credits-panel" id="buyCreditsPanel" style="display:none">
        <span class="buy-credits-label">Buy generation credits:</span>
        <button class="ctrl-btn credit-pack-btn" data-pack="starter">10 credits — $4.99</button>
        <button class="ctrl-btn credit-pack-btn" data-pack="pro">30 credits — $9.99</button>
        <button class="ctrl-btn credit-pack-btn" data-pack="studio">100 credits — $24.99</button>
      </div>
      <div class="generate-output" id="generateOutput">
        <span class="generate-status" id="generateStatus"></span>
        <audio class="generate-player" id="generatePlayer" controls></audio>
        <a class="ctrl-btn download-btn" id="downloadBtn" download="backing-track.mp3">Download</a>
      </div>
    </div>
  </section>

</Layout>

<style is:global>
/* ═══════════════════════════════════════════
   Font Variables (used throughout Chord Palette CSS)
   ═══════════════════════════════════════════ */
.palette-header,
.scale-selector,
.grid-section,
.diagram-section,
.progression-section {
  --font-serif: 'Playfair Display', serif;
  --font-sans: 'IBM Plex Sans', sans-serif;
  --font-mono: 'IBM Plex Mono', monospace;
}

/* ═══════════════════════════════════════════
   Page Header
   ═══════════════════════════════════════════ */
.palette-header {
  margin-bottom: 2rem;
  border-bottom: 1px solid var(--rule);
  padding: 2rem 0 1rem;
}

.palette-header h1 {
  font-family: var(--font-serif);
  font-weight: 900;
  font-size: 2rem;
  letter-spacing: -0.02em;
  color: var(--ink);
}

.palette-header h1 span {
  color: var(--red);
}

/* ═══════════════════════════════════════════
   Scale Selector
   ═══════════════════════════════════════════ */
.scale-selector {
  margin-bottom: 2rem;
}

.selector-label {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--ink-faded);
  margin-bottom: 0.5rem;
  display: block;
}

.root-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 0;
  margin-bottom: 1rem;
  border: 1px solid var(--rule);
}

.root-btn {
  flex: 1;
  min-width: 0;
  padding: 0.5rem 0;
  background: var(--card-bg);
  border: none;
  border-right: 1px solid var(--rule);
  color: var(--ink);
  font-family: var(--font-mono);
  font-size: 0.8rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
  text-align: center;
}

.root-btn:last-child { border-right: none; }

.root-btn:hover {
  background: var(--card-hover);
}

.root-btn.active {
  background: var(--ink);
  color: var(--cream);
}

@media (max-width: 600px) {
  .root-buttons {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
  }
  .root-btn {
    border-right: 1px solid var(--rule);
    border-bottom: 1px solid var(--rule);
    padding: 0.6rem 0;
  }
  .root-btn:nth-child(6) { border-right: none; }
  .root-btn:nth-child(n+7) { border-bottom: none; }
  .root-btn:last-child { border-right: none; }
}

.scale-row {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex-wrap: wrap;
}

.scale-select {
  font-family: var(--font-mono);
  font-size: 0.8rem;
  padding: 0.45rem 0.75rem;
  background: var(--card-bg);
  border: 1px solid var(--rule);
  color: var(--ink);
  cursor: pointer;
  -webkit-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%235a4f3f' fill='none' stroke-width='1.5'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 0.7rem center;
  padding-right: 2rem;
}

html.dark .scale-select {
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%236b5e42' fill='none' stroke-width='1.5'/%3E%3C/svg%3E");
}

.scale-label {
  font-family: var(--font-serif);
  font-size: 1.3rem;
  font-weight: 700;
  color: var(--ink);
}

/* ═══════════════════════════════════════════
   Chord Grid
   ═══════════════════════════════════════════ */
.grid-section {
  margin-bottom: 2rem;
}

.chord-grid {
  display: grid;
  grid-template-columns: auto repeat(7, 1fr);
  border: 1px solid var(--rule);
  overflow-x: auto;
}

.grid-header {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--ink-faded);
  padding: 0.6rem 0.4rem;
  text-align: center;
  border-bottom: 1px solid var(--rule);
  border-right: 1px solid var(--rule);
  background: var(--paper);
  white-space: nowrap;
}

.grid-header .roman {
  display: block;
  font-size: 0.85rem;
  color: var(--ink);
  font-weight: 500;
}

.grid-header .note-name {
  display: block;
  font-size: 0.65rem;
  color: var(--ink-faded);
  margin-top: 0.1rem;
}

.row-label {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--ink-faded);
  padding: 0.5rem 0.6rem;
  text-align: right;
  border-bottom: 1px solid var(--rule);
  border-right: 1px solid var(--rule);
  background: var(--paper);
  display: flex;
  align-items: center;
  justify-content: flex-end;
  white-space: nowrap;
}

.chord-cell {
  padding: 0.4rem 0.2rem;
  text-align: center;
  border-bottom: 1px solid var(--rule);
  border-right: 1px solid var(--rule);
  cursor: pointer;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 2.4rem;
}

.chord-grid > :nth-child(8n) { border-right: none; }
.chord-grid > :nth-last-child(-n+8) { border-bottom: none; }

.chord-cell:hover {
  background: var(--card-hover);
}

.chord-cell.active {
  background: var(--ink);
  color: var(--cream);
}

.chord-cell.active .cell-name {
  color: var(--cream);
}

.chord-cell.empty {
  cursor: default;
  background: var(--paper);
  opacity: 0.4;
}

.chord-cell.empty:hover {
  background: var(--paper);
}

.cell-name {
  font-family: var(--font-mono);
  font-size: 0.72rem;
  font-weight: 500;
  color: var(--ink);
  line-height: 1.2;
}

/* Triad row emphasis */
.chord-cell.triad-row:not(.empty) {
  min-height: 2.8rem;
}

.chord-cell.triad-row .cell-name {
  font-size: 0.82rem;
  font-weight: 500;
}

/* ═══════════════════════════════════════════
   Chord Diagram
   ═══════════════════════════════════════════ */
.diagram-section {
  margin-bottom: 2rem;
  border: 1px solid var(--rule);
  padding: 1.5rem;
  display: none;
}

.diagram-section.visible {
  display: block;
}

.diagram-header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.diagram-chord-name {
  font-family: var(--font-serif);
  font-size: 1.4rem;
  font-weight: 700;
}

.diagram-quality {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--ink-faded);
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.diagram-container {
  display: flex;
  align-items: flex-start;
  justify-content: center;
  gap: 2rem;
  flex-wrap: wrap;
}

.diagram-svg-wrap {
  flex-shrink: 0;
}

.diagram-notes {
  font-family: var(--font-mono);
  font-size: 0.75rem;
  color: var(--ink-faded);
  margin-top: 1rem;
  text-align: center;
}

.add-to-progression {
  display: block;
  margin: 1rem auto 0;
  font-family: var(--font-mono);
  font-size: 0.7rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  padding: 0.55rem 1.25rem;
  background: var(--ink);
  color: var(--cream);
  border: none;
  cursor: pointer;
  transition: all 0.15s ease;
}

.add-to-progression:hover {
  opacity: 0.85;
}

.add-to-progression:active {
  transform: scale(0.97);
}

/* ═══════════════════════════════════════════
   Progression Builder
   ═══════════════════════════════════════════ */
.progression-section {
  border: 1px solid var(--rule);
  padding: 1.25rem;
}

.progression-section .selector-label {
  margin-bottom: 0.75rem;
}

.progression-strip {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  min-height: 2.5rem;
  padding: 0.5rem;
  border: 1px solid var(--rule);
  background: var(--paper);
  margin-bottom: 1rem;
  align-items: center;
}

.progression-strip.empty-state {
  justify-content: center;
}

.progression-strip.empty-state::after {
  content: 'Select a chord, then press + Add to build a progression';
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--ink-faded);
  letter-spacing: 0.05em;
}

.chord-chip {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  padding: 0.35rem 0.6rem;
  background: var(--card-bg);
  border: 1px solid var(--rule);
  font-family: var(--font-mono);
  font-size: 0.75rem;
  font-weight: 500;
  color: var(--ink);
  cursor: grab;
  transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
  user-select: none;
  touch-action: none;
}

.chord-chip:hover {
  background: var(--card-hover);
}

.chord-chip.playing {
  background: var(--ink);
  color: var(--cream);
  border-color: var(--ink);
}

.chord-chip.dragging {
  opacity: 0.2;
  cursor: grabbing;
}

.chord-chip.drop-before::before {
  content: '';
  position: absolute;
  left: -4px;
  top: -2px;
  bottom: -2px;
  width: 2px;
  background: var(--red);
  border-radius: 1px;
}

.chord-chip.drop-after::after {
  content: '';
  position: absolute;
  right: -4px;
  top: -2px;
  bottom: -2px;
  width: 2px;
  background: var(--red);
  border-radius: 1px;
}

.drag-ghost {
  position: fixed;
  z-index: 999;
  pointer-events: none;
  display: inline-flex;
  align-items: center;
  padding: 0.35rem 0.6rem;
  background: var(--ink);
  color: var(--cream);
  border: 1px solid var(--ink);
  font-family: var(--font-mono);
  font-size: 0.75rem;
  font-weight: 500;
  opacity: 0.9;
  white-space: nowrap;
}

.chip-remove {
  font-size: 0.65rem;
  color: var(--ink-faded);
  cursor: pointer;
  padding: 0 0.1rem;
  line-height: 1;
}

.chip-remove:hover {
  color: var(--red);
}

.progression-controls {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex-wrap: wrap;
}

.ctrl-btn {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  padding: 0.5rem 1rem;
  background: var(--ink);
  color: var(--cream);
  border: none;
  cursor: pointer;
  transition: all 0.15s ease;
}

.ctrl-btn:hover {
  opacity: 0.85;
}

.ctrl-btn:disabled {
  opacity: 0.4;
  cursor: default;
}

.ctrl-btn.stop-btn {
  background: var(--red);
}

.ctrl-btn.clear-btn {
  background: none;
  color: var(--ink-faded);
  border: 1px solid var(--rule);
}

.ctrl-btn.clear-btn:hover {
  color: var(--ink);
  border-color: var(--ink-faded);
}

.bpm-control {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-left: auto;
}

.bpm-label {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--ink-faded);
  letter-spacing: 0.05em;
  min-width: 5ch;
  text-align: right;
}

.bpm-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 100px;
  height: 3px;
  background: var(--rule);
  outline: none;
  cursor: pointer;
}

.bpm-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px;
  height: 12px;
  background: var(--ink);
  border-radius: 0;
  cursor: pointer;
}

.bpm-slider::-moz-range-thumb {
  width: 12px;
  height: 12px;
  background: var(--ink);
  border: none;
  border-radius: 0;
  cursor: pointer;
}

/* ── Progression Settings Row ── */
.progression-settings {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex-wrap: wrap;
  margin-top: 0.75rem;
  padding-top: 0.75rem;
  border-top: 1px solid var(--rule);
}

.setting-group {
  display: flex;
  align-items: center;
  gap: 0.35rem;
}

.setting-label {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--ink-faded);
}

.setting-select {
  font-family: var(--font-mono);
  font-size: 0.75rem;
  padding: 0.3rem 0.5rem;
  background: var(--card-bg);
  border: 1px solid var(--rule);
  color: var(--ink);
  cursor: pointer;
  -webkit-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%235a4f3f' fill='none' stroke-width='1.5'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 0.4rem center;
  padding-right: 1.4rem;
}

html.dark .setting-select {
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%236b5e42' fill='none' stroke-width='1.5'/%3E%3C/svg%3E");
}

.setting-toggle {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  padding: 0.3rem 0.6rem;
  background: none;
  border: 1px solid var(--rule);
  color: var(--ink-faded);
  cursor: pointer;
  transition: all 0.15s ease;
}

.setting-toggle:hover {
  color: var(--ink);
  border-color: var(--ink-faded);
}

.setting-toggle.active {
  background: var(--ink);
  color: var(--cream);
  border-color: var(--ink);
}

/* ── Generate Section ── */
.generate-section {
  margin-top: 0.75rem;
  padding-top: 0.75rem;
  border-top: 1px solid var(--rule);
}

.generate-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.style-input {
  flex: 1;
  min-width: 160px;
  font-family: var(--font-mono);
  font-size: 0.75rem;
  padding: 0.45rem 0.6rem;
  background: var(--card-bg);
  border: 1px solid var(--rule);
  color: var(--ink);
  outline: none;
  transition: border-color 0.15s ease;
}

.style-input::placeholder {
  color: var(--ink-faded);
  opacity: 0.7;
}

.style-input:focus {
  border-color: var(--ink-faded);
}

.generate-btn {
  background: var(--red);
  white-space: nowrap;
}

.generate-output {
  display: none;
  align-items: center;
  gap: 0.75rem;
  margin-top: 0.75rem;
  flex-wrap: wrap;
}

.generate-output.visible {
  display: flex;
}

.generate-status {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--ink-faded);
  letter-spacing: 0.05em;
}

.generate-status.active {
  animation: palette-pulse 1.5s ease infinite;
}

.generate-status.error {
  color: var(--red);
}

.generate-player {
  display: none;
  height: 36px;
  max-width: 300px;
  flex: 1;
}

.generate-player.visible {
  display: block;
}

.download-btn {
  display: none;
  background: none;
  color: var(--ink-faded);
  border: 1px solid var(--rule);
  text-decoration: none;
  text-align: center;
  font-family: var(--font-mono);
  font-size: 0.7rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  padding: 0.5rem 1rem;
  cursor: pointer;
  transition: all 0.15s ease;
}

.download-btn.visible {
  display: inline-block;
}

/* ── Credit Badge ── */
.credit-badge {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  font-weight: 600;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  padding: 0.25rem 0.6rem;
  background: var(--card-bg);
  border: 1px solid var(--rule);
  color: var(--ink-faded);
  white-space: nowrap;
}

.credit-badge.low {
  color: var(--red);
  border-color: var(--red);
}

/* ── Buy Credits Panel ── */
.buy-credits-panel {
  display: none;
  align-items: center;
  gap: 0.5rem;
  margin-top: 0.6rem;
  flex-wrap: wrap;
}

.buy-credits-panel.visible {
  display: flex;
}

.buy-credits-label {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--ink-faded);
  letter-spacing: 0.05em;
  margin-right: 0.25rem;
}

.credit-pack-btn {
  background: none;
  color: var(--ink);
  border: 1px solid var(--rule);
  font-family: var(--font-mono);
  font-size: 0.65rem;
  font-weight: 500;
  letter-spacing: 0.04em;
  padding: 0.4rem 0.7rem;
  cursor: pointer;
  transition: all 0.15s ease;
}

.credit-pack-btn:hover {
  border-color: var(--ink-faded);
  background: var(--card-bg);
}

.download-btn:hover {
  color: var(--ink);
  border-color: var(--ink-faded);
}

/* ═══════════════════════════════════════════
   Loading State
   ═══════════════════════════════════════════ */
.loading-indicator {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--ink-faded);
  letter-spacing: 0.05em;
}

@keyframes palette-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

.loading-indicator.active {
  animation: palette-pulse 1.5s ease infinite;
}

/* ═══════════════════════════════════════════
   Responsive
   ═══════════════════════════════════════════ */
@media (max-width: 768px) {
  .palette-header h1 { font-size: 1.5rem; }
  .scale-label { font-size: 1.1rem; }
  .chord-grid { font-size: 0.85rem; }
  .bpm-control { margin-left: 0; width: 100%; margin-top: 0.5rem; }
  .progression-settings { gap: 0.75rem; }
  .generate-row { flex-direction: column; align-items: stretch; }
  .style-input { min-width: 0; }
  .credit-badge { align-self: flex-start; }
  .buy-credits-panel { flex-direction: column; align-items: stretch; }
  .generate-output { flex-direction: column; align-items: stretch; }
  .generate-player { max-width: 100%; }
}

@media (max-width: 480px) {
  .chord-grid {
    grid-template-columns: auto repeat(7, minmax(38px, 1fr));
  }
  .cell-name { font-size: 0.6rem; }
  .chord-cell.triad-row .cell-name { font-size: 0.7rem; }
  .grid-header { font-size: 0.6rem; padding: 0.4rem 0.2rem; }
  .grid-header .roman { font-size: 0.7rem; }
  .row-label { font-size: 0.55rem; padding: 0.4rem 0.3rem; }
  .diagram-section { padding: 1rem; }
}
</style>

<script>
  import { supabase, supabaseConfigured, supabaseUrl, supabaseAnonKey } from '../lib/supabase.js';

  let Tone;
  let cleanup = null;

  // Clean up on View Transitions navigation
  document.addEventListener('astro:before-swap', () => {
    if (cleanup) { cleanup(); cleanup = null; }
  });

  document.addEventListener('astro:page-load', () => {
    // Only initialize on the chord-palette page
    if (!document.getElementById('chordGrid')) return;

    // ─── Lazy Tone.js loader ───
    async function loadTone() {
      if (Tone) return;
      const ToneModule = await import('tone');
      Tone = ToneModule.default || ToneModule;
    }

    /* ═══════════════════════════════════════════════════════════════
       1. MUSIC THEORY ENGINE
       ═══════════════════════════════════════════════════════════════ */
    const MusicTheory = (() => {
      const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

      const SCALES = {
        'Major':                [0,2,4,5,7,9,11],
        'Natural Minor':        [0,2,3,5,7,8,10],
        'Harmonic Minor':       [0,2,3,5,7,8,11],
        'Melodic Minor':        [0,2,3,5,7,9,11],
        'Harmonic Major':       [0,2,4,5,7,8,11],
        'Double Harmonic Major':[0,1,4,5,7,8,11],
        'Neapolitan Major':     [0,1,3,5,7,9,11],
        'Neapolitan Minor':     [0,1,3,5,7,8,11],
        'Dorian':               [0,2,3,5,7,9,10],
        'Phrygian':             [0,1,3,5,7,8,10],
        'Lydian':               [0,2,4,6,7,9,11],
        'Mixolydian':           [0,2,4,5,7,9,10],
        'Locrian':              [0,1,3,5,6,8,10],
      };

      const SCALE_GROUPS = {
        'Common':   ['Major','Natural Minor'],
        'Extended': ['Harmonic Minor','Melodic Minor','Harmonic Major','Double Harmonic Major','Neapolitan Major','Neapolitan Minor'],
        'Modes':    ['Dorian','Phrygian','Lydian','Mixolydian','Locrian'],
      };

      const CHORD_FORMULAS = {
        'maj':[0,4,7], 'min':[0,3,7], 'dim':[0,3,6], 'aug':[0,4,8],
        'sus2':[0,2,7], 'sus4':[0,5,7],
        'maj7':[0,4,7,11], 'min7':[0,3,7,10], 'dom7':[0,4,7,10],
        'm7b5':[0,3,6,10], 'dim7':[0,3,6,9],
        'minMaj7':[0,3,7,11], 'augMaj7':[0,4,8,11], 'aug7':[0,4,8,10],
      };

      const ROMAN = ['I','II','III','IV','V','VI','VII'];

      const LETTERS = ['C','D','E','F','G','A','B'];
      const NATURAL_PC = [0, 2, 4, 5, 7, 9, 11];

      function rootLetterIndex(pc) {
        const nat = {0:0, 2:1, 4:2, 5:3, 7:4, 9:5, 11:6};
        if (nat[pc] !== undefined) return nat[pc];
        const acc = {1:1, 3:2, 6:3, 8:5, 10:6};
        return acc[pc];
      }

      function getScaleNoteNames(rootPc, scaleType) {
        const intervals = SCALES[scaleType];
        const rli = rootLetterIndex(rootPc);
        return intervals.map((interval, d) => {
          const letterIdx = (rli + d) % 7;
          const naturalPc = NATURAL_PC[letterIdx];
          const actualPc = (rootPc + interval) % 12;
          const diff = (actualPc - naturalPc + 12) % 12;
          const letter = LETTERS[letterIdx];
          if (diff === 0) return letter;
          if (diff === 1) return letter + '#';
          if (diff === 11) return letter + 'b';
          if (diff === 2) return letter + '##';
          if (diff === 10) return letter + 'bb';
          return letter;
        });
      }

      function getRootName(pc) {
        const li = rootLetterIndex(pc);
        const naturalPc = NATURAL_PC[li];
        const diff = (pc - naturalPc + 12) % 12;
        const letter = LETTERS[li];
        if (diff === 1) return letter + '#';
        if (diff === 11) return letter + 'b';
        return letter;
      }

      function getScalePitchClasses(rootPc, scaleType) {
        return SCALES[scaleType].map(i => (rootPc + i) % 12);
      }

      function getTriadQuality(rootPc, scaleType, degree) {
        const intervals = SCALES[scaleType];
        const root = (rootPc + intervals[degree]) % 12;
        const third = (rootPc + intervals[(degree + 2) % 7]) % 12;
        const fifth = (rootPc + intervals[(degree + 4) % 7]) % 12;
        const i3 = (third - root + 12) % 12;
        const i5 = (fifth - root + 12) % 12;
        if (i3 === 4 && i5 === 7) return 'maj';
        if (i3 === 3 && i5 === 7) return 'min';
        if (i3 === 3 && i5 === 6) return 'dim';
        if (i3 === 4 && i5 === 8) return 'aug';
        return 'maj';
      }

      function get7thQuality(rootPc, scaleType, degree) {
        const triad = getTriadQuality(rootPc, scaleType, degree);
        const intervals = SCALES[scaleType];
        const root = (rootPc + intervals[degree]) % 12;
        const seventh = (rootPc + intervals[(degree + 6) % 7]) % 12;
        const i7 = (seventh - root + 12) % 12;
        if (triad === 'maj' && i7 === 11) return 'maj7';
        if (triad === 'maj' && i7 === 10) return 'dom7';
        if (triad === 'min' && i7 === 10) return 'min7';
        if (triad === 'min' && i7 === 11) return 'minMaj7';
        if (triad === 'dim' && i7 === 10) return 'm7b5';
        if (triad === 'dim' && i7 === 9) return 'dim7';
        if (triad === 'aug' && i7 === 11) return 'augMaj7';
        if (triad === 'aug' && i7 === 10) return 'aug7';
        return 'dom7';
      }

      function isSusDiatonic(rootPc, scaleType, degree, susType) {
        const pcs = getScalePitchClasses(rootPc, scaleType);
        const intervals = SCALES[scaleType];
        const chordRoot = (rootPc + intervals[degree]) % 12;
        return CHORD_FORMULAS[susType].every(i => pcs.includes((chordRoot + i) % 12));
      }

      function romanNumeral(degree, quality) {
        let r = ROMAN[degree];
        if (['min','dim','min7','m7b5','dim7','minMaj7'].includes(quality)) r = r.toLowerCase();
        if (quality === 'dim') r += '\u00B0';
        if (quality === 'aug') r += '+';
        return r;
      }

      function chordSuffix(quality) {
        const map = {
          'maj':'', 'min':'m', 'dim':'dim', 'aug':'aug',
          'sus2':'sus2', 'sus4':'sus4',
          'maj7':'maj7', 'min7':'m7', 'dom7':'7',
          'm7b5':'m7\u266D5', 'dim7':'dim7',
          'minMaj7':'m(maj7)', 'augMaj7':'aug(maj7)', 'aug7':'aug7',
        };
        return map[quality] || quality;
      }

      function buildGrid(rootPc, scaleType) {
        const intervals = SCALES[scaleType];
        const noteNames = getScaleNoteNames(rootPc, scaleType);
        const degrees = [];

        for (let d = 0; d < 7; d++) {
          const degreePc = (rootPc + intervals[d]) % 12;
          const triadQ = getTriadQuality(rootPc, scaleType, d);
          const seventhQ = get7thQuality(rootPc, scaleType, d);

          degrees.push({
            degree: d,
            pc: degreePc,
            note: noteNames[d],
            roman: romanNumeral(d, triadQ),
            triad: triadQ,
            seventh: seventhQ,
            sus2: isSusDiatonic(rootPc, scaleType, d, 'sus2') ? 'sus2' : null,
            sus4: isSusDiatonic(rootPc, scaleType, d, 'sus4') ? 'sus4' : null,
          });
        }
        return degrees;
      }

      const MUSICGEN_QUALITY_MAP = {
        'maj': '', 'min': 'min', 'dim': 'dim', 'aug': 'aug',
        'sus2': 'sus2', 'sus4': 'sus4',
        'maj7': 'maj7', 'min7': 'min7', 'dom7': '7',
        'm7b5': 'hdim7', 'dim7': 'dim7',
        'minMaj7': 'minmaj7', 'augMaj7': 'maj7', 'aug7': '7',
      };

      function toMusicGenChords(progression) {
        return progression.map(chord => {
          const root = NOTE_NAMES[chord.pc];
          const type = MUSICGEN_QUALITY_MAP[chord.quality] || '';
          return type ? `${root}:${type}` : root;
        }).join(' ');
      }

      return {
        NOTE_NAMES, SCALES, SCALE_GROUPS, CHORD_FORMULAS, ROMAN,
        getRootName, getScaleNoteNames, getScalePitchClasses,
        buildGrid, chordSuffix, getTriadQuality, get7thQuality,
        toMusicGenChords,
      };
    })();


    /* ═══════════════════════════════════════════════════════════════
       2. VOICING ENGINE
       ═══════════════════════════════════════════════════════════════ */
    const VoicingEngine = (() => {
      const TUNING = [40, 45, 50, 55, 59, 64];

      const KNOWN = {
        'maj_0':[-1,3,2,0,1,0],'maj_1':[-1,4,6,6,6,4],'maj_2':[-1,-1,0,2,3,2],
        'maj_3':[-1,-1,1,3,4,3],'maj_4':[0,2,2,1,0,0],'maj_5':[1,3,3,2,1,1],
        'maj_6':[2,4,4,3,2,2],'maj_7':[3,2,0,0,0,3],'maj_8':[4,6,6,5,4,4],
        'maj_9':[-1,0,2,2,2,0],'maj_10':[-1,1,3,3,3,1],'maj_11':[-1,2,4,4,4,2],
        'min_0':[-1,3,5,5,4,3],'min_1':[-1,4,6,6,5,4],'min_2':[-1,-1,0,2,3,1],
        'min_3':[-1,-1,1,3,4,2],'min_4':[0,2,2,0,0,0],'min_5':[1,3,3,1,1,1],
        'min_6':[2,4,4,2,2,2],'min_7':[3,5,5,3,3,3],'min_8':[4,6,6,4,4,4],
        'min_9':[-1,0,2,2,1,0],'min_10':[-1,1,3,3,2,1],'min_11':[-1,2,4,4,3,2],
        'dom7_0':[-1,3,2,3,1,0],'dom7_1':[-1,4,3,4,2,-1],'dom7_2':[-1,-1,0,2,1,2],
        'dom7_3':[-1,-1,1,3,2,3],'dom7_4':[0,2,0,1,0,0],'dom7_5':[1,3,1,2,1,1],
        'dom7_6':[2,4,2,3,2,2],'dom7_7':[3,2,0,0,0,1],'dom7_8':[4,6,4,5,4,4],
        'dom7_9':[-1,0,2,0,2,0],'dom7_10':[-1,1,3,1,3,1],'dom7_11':[-1,2,1,2,0,2],
        'maj7_0':[-1,3,2,0,0,0],'maj7_1':[-1,4,3,1,1,1],'maj7_2':[-1,-1,0,2,2,2],
        'maj7_3':[-1,-1,1,3,3,3],'maj7_4':[0,2,1,1,0,0],'maj7_5':[1,3,3,2,1,0],
        'maj7_6':[2,4,3,3,2,2],'maj7_7':[3,2,0,0,0,2],'maj7_8':[4,6,5,5,4,4],
        'maj7_9':[-1,0,2,1,2,0],'maj7_10':[-1,1,3,2,3,1],'maj7_11':[-1,2,4,3,4,2],
        'min7_0':[-1,3,5,3,4,3],'min7_1':[-1,4,6,4,5,4],'min7_2':[-1,-1,0,2,1,1],
        'min7_3':[-1,-1,1,3,2,2],'min7_4':[0,2,0,0,0,0],'min7_5':[1,3,1,1,1,1],
        'min7_6':[2,4,2,2,2,2],'min7_7':[3,5,3,3,3,3],'min7_8':[4,6,4,4,4,4],
        'min7_9':[-1,0,2,0,1,0],'min7_10':[-1,1,3,1,2,1],'min7_11':[-1,2,0,2,0,2],
        'sus2_2':[-1,-1,0,2,3,0],'sus2_4':[0,2,4,4,0,0],'sus2_9':[-1,0,2,2,0,0],
        'sus4_2':[-1,-1,0,2,3,3],'sus4_4':[0,2,2,2,0,0],'sus4_9':[-1,0,2,2,3,0],
      };

      const BARRE_TEMPLATES = {
        'maj':     [{ shape: [0,2,2,1,0,0], rs: 0 }, { shape: [-1,0,2,2,2,0], rs: 1 }],
        'min':     [{ shape: [0,2,2,0,0,0], rs: 0 }, { shape: [-1,0,2,2,1,0], rs: 1 }],
        'dim':     [{ shape: [-1,-1,0,1,0,1], rs: 2 }, { shape: [-1,0,1,2,1,-1], rs: 1 }],
        'aug':     [{ shape: [-1,0,3,2,2,1], rs: 1 }],
        'sus2':    [{ shape: [-1,0,2,2,0,0], rs: 1 }, { shape: [0,2,4,4,0,0], rs: 0 }],
        'sus4':    [{ shape: [-1,0,2,2,3,0], rs: 1 }, { shape: [0,2,2,2,0,0], rs: 0 }],
        'maj7':    [{ shape: [-1,0,2,1,2,0], rs: 1 }, { shape: [0,2,1,1,0,0], rs: 0 }],
        'min7':    [{ shape: [-1,0,2,0,1,0], rs: 1 }, { shape: [0,2,0,0,0,0], rs: 0 }],
        'dom7':    [{ shape: [-1,0,2,0,2,0], rs: 1 }, { shape: [0,2,0,1,0,0], rs: 0 }],
        'm7b5':    [{ shape: [-1,0,1,0,1,0], rs: 1 }, { shape: [-1,-1,0,1,1,1], rs: 2 }],
        'dim7':    [{ shape: [-1,0,1,2,1,2], rs: 1 }, { shape: [-1,-1,0,1,0,1], rs: 2 }],
        'minMaj7': [{ shape: [-1,0,2,1,1,0], rs: 1 }, { shape: [0,2,1,0,0,0], rs: 0 }],
        'augMaj7': [{ shape: [-1,0,3,2,2,0], rs: 1 }],
        'aug7':    [{ shape: [-1,0,3,0,2,1], rs: 1 }],
      };

      function transposeTemplate(tmpl, targetPc) {
        const rootMidi = TUNING[tmpl.rs] + tmpl.shape[tmpl.rs];
        const rootPc = rootMidi % 12;
        const shift = (targetPc - rootPc + 12) % 12;
        return tmpl.shape.map((f, i) => f === -1 ? -1 : f + shift);
      }

      function validateVoicing(frets) {
        const played = frets.filter(f => f > 0);
        if (played.length === 0) return true;
        const maxFret = Math.max(...played);
        const minFret = Math.min(...played);
        if (maxFret > 18) return false;
        if (maxFret - minFret > 4) return false;
        if (played.length > 6) return false;
        return true;
      }

      function scoreVoicing(frets) {
        const fretted = frets.filter(f => f > 0);
        const maxFret = fretted.length ? Math.max(...fretted) : 0;
        const openCount = frets.filter(f => f === 0).length;
        const playedCount = frets.filter(f => f >= 0).length;
        let score = maxFret * 2 - playedCount * 3 - openCount * 2;
        if (fretted.length > 1) {
          score += (Math.max(...fretted) - Math.min(...fretted)) * 1.5;
        }
        return score;
      }

      function getVoicing(quality, targetPc) {
        const key = quality + '_' + targetPc;
        if (KNOWN[key]) return [...KNOWN[key]];
        const templates = BARRE_TEMPLATES[quality];
        if (!templates) return null;
        let best = null;
        let bestScore = Infinity;
        for (const tmpl of templates) {
          const frets = transposeTemplate(tmpl, targetPc);
          if (!validateVoicing(frets)) continue;
          const s = scoreVoicing(frets);
          if (s < bestScore) { bestScore = s; best = frets; }
        }
        return best;
      }

      function fretsToMidi(frets) {
        return frets.map((f, i) => f === -1 ? null : TUNING[i] + f);
      }

      function midiToNoteName(midi) {
        const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
        return names[midi % 12] + (Math.floor(midi / 12) - 1);
      }

      function getDiagramData(frets) {
        const played = frets.filter(f => f > 0);
        if (played.length === 0) {
          return { displayFrets: frets, baseFret: 1, showNut: true };
        }
        const minFret = Math.min(...played);
        const maxFret = Math.max(...played);
        if (maxFret <= 5) {
          return { displayFrets: frets, baseFret: 1, showNut: true };
        }
        const base = minFret;
        const df = frets.map(f => f <= 0 ? f : f - base + 1);
        return { displayFrets: df, baseFret: base, showNut: false };
      }

      return { TUNING, getVoicing, fretsToMidi, midiToNoteName, getDiagramData };
    })();


    /* ═══════════════════════════════════════════════════════════════
       3. AUDIO ENGINE (lazy-loads Tone.js on first interaction)
       ═══════════════════════════════════════════════════════════════ */
    const AudioEngine = (() => {
      let sampler = null;
      let loaded = false;
      let loading = false;
      let clickHi = null;
      let clickLo = null;

      async function ensureReady() {
        await loadTone();
        await Tone.start();
        if (!loaded && !loading) {
          loading = true;
          const loadingEl = document.getElementById('loadingIndicator');
          if (loadingEl) {
            loadingEl.textContent = 'Loading samples...';
            loadingEl.classList.add('active');
          }
          return new Promise((resolve) => {
            sampler = new Tone.Sampler({
              urls: {
                'A2': 'A2.mp3', 'C3': 'C3.mp3', 'D#3': 'Ds3.mp3', 'F#3': 'Fs3.mp3',
                'A3': 'A3.mp3', 'C4': 'C4.mp3', 'D#4': 'Ds4.mp3', 'F#4': 'Fs4.mp3',
                'A4': 'A4.mp3', 'C5': 'C5.mp3',
              },
              baseUrl: 'https://cdn.jsdelivr.net/gh/nbrosowsky/tonejs-instruments/samples/guitar-acoustic/',
              release: 1.5,
              onload: () => {
                loaded = true;
                loading = false;
                sampler.volume.value = -6;
                if (loadingEl) {
                  loadingEl.textContent = 'Ready';
                  loadingEl.classList.remove('active');
                  setTimeout(() => { loadingEl.style.display = 'none'; }, 1500);
                }
                resolve();
              },
              onerror: (e) => {
                console.error('Sample load error:', e);
                loading = false;
                if (loadingEl) {
                  loadingEl.textContent = 'Audio error';
                  loadingEl.classList.remove('active');
                }
                resolve();
              }
            }).toDestination();
          });
        }
        if (loading) {
          return new Promise((resolve) => {
            const check = setInterval(() => {
              if (loaded || !loading) { clearInterval(check); resolve(); }
            }, 100);
          });
        }
        // Lazy-init metronome synths
        if (!clickHi) {
          clickHi = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.01 },
            volume: -10,
          }).toDestination();
        }
        if (!clickLo) {
          clickLo = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.01 },
            volume: -16,
          }).toDestination();
        }
      }

      function scheduleClick(time, accent) {
        if (accent) {
          clickHi.triggerAttackRelease('G5', '32n', time);
        } else {
          clickLo.triggerAttackRelease('C5', '32n', time);
        }
      }

      async function strumChord(midiNotes) {
        await ensureReady();
        const now = Tone.now();
        const strumDelay = 0.018;
        const notes = midiNotes.filter(n => n !== null);
        notes.forEach((midi, i) => {
          sampler.triggerAttackRelease(
            VoicingEngine.midiToNoteName(midi), '2n', now + i * strumDelay
          );
        });
      }

      const SAMPLE_ANTICIPATION = 0.035;

      function scheduleChord(midiNotes, time) {
        const notes = midiNotes.filter(n => n !== null);
        const strumDelay = 0.018;
        const t0 = time - SAMPLE_ANTICIPATION;
        notes.forEach((midi, i) => {
          sampler.triggerAttackRelease(
            VoicingEngine.midiToNoteName(midi), '2n', t0 + i * strumDelay
          );
        });
      }

      function isLoaded() { return loaded; }
      function getSampler() { return sampler; }

      return { ensureReady, strumChord, scheduleChord, scheduleClick, isLoaded, getSampler };
    })();


    /* ═══════════════════════════════════════════════════════════════
       4. APP STATE
       ═══════════════════════════════════════════════════════════════ */
    const AppState = (() => {
      const state = {
        rootPc: 0,
        scaleType: 'Major',
        activeChord: null,
        progression: [],
        bpm: 100,
        isPlaying: false,
        loop: false,
        playType: 'strum',
        timeSig: '4/4',
        metronome: false,
        generateStatus: 'idle',
        generateStyle: '',
        generatedTrackUrl: null,
        userCredits: null,
      };

      const listeners = new Set();

      function get() { return state; }

      function set(updates) {
        Object.assign(state, updates);
        listeners.forEach(fn => fn(state));
      }

      function subscribe(fn) {
        listeners.add(fn);
        return () => listeners.delete(fn);
      }

      return { get, set, subscribe };
    })();


    /* ═══════════════════════════════════════════════════════════════
       5. CHORD DIAGRAM (SVG)
       ═══════════════════════════════════════════════════════════════ */
    const ChordDiagram = (() => {
      const STRINGS = 6;
      const FRETS = 5;
      const stringSpacing = 24;
      const fretSpacing = 30;
      const dotRadius = 8;
      const fontSize = 12;
      const topPad = 28;
      const leftPad = 32;
      const nutWidth = 4;

      function render(frets) {
        if (!frets) return '';

        const { displayFrets, baseFret, showNut } = VoicingEngine.getDiagramData(frets);
        const diagramW = (STRINGS - 1) * stringSpacing;
        const diagramH = FRETS * fretSpacing;
        const svgW = leftPad + diagramW + 16;
        const svgH = topPad + diagramH + 12;

        let svg = `<svg width="${svgW}" height="${svgH}" viewBox="0 0 ${svgW} ${svgH}" xmlns="http://www.w3.org/2000/svg" style="max-width:260px;">`;

        if (showNut) {
          svg += `<rect x="${leftPad - 1}" y="${topPad - nutWidth}" width="${diagramW + 2}" height="${nutWidth}" rx="1" fill="var(--diagram-nut)"/>`;
        } else {
          svg += `<text x="${leftPad - 10}" y="${topPad + fretSpacing / 2 + 4}" text-anchor="middle" font-size="${fontSize}" font-family="var(--font-mono)" fill="var(--diagram-mute)">${baseFret}</text>`;
        }

        for (let f = 0; f <= FRETS; f++) {
          const y = topPad + f * fretSpacing;
          svg += `<line x1="${leftPad}" y1="${y}" x2="${leftPad + diagramW}" y2="${y}" stroke="var(--diagram-line)" stroke-width="0.8"/>`;
        }

        for (let s = 0; s < STRINGS; s++) {
          const x = leftPad + s * stringSpacing;
          const sw = (s === 0 || s === 5) ? 1.5 : 1;
          svg += `<line x1="${x}" y1="${topPad}" x2="${x}" y2="${topPad + diagramH}" stroke="var(--diagram-line)" stroke-width="${sw}"/>`;
        }

        for (let s = 0; s < STRINGS; s++) {
          const x = leftPad + s * stringSpacing;
          const fret = displayFrets[s];

          if (fret === -1) {
            svg += `<text x="${x}" y="${topPad - 10}" text-anchor="middle" font-size="${fontSize}" font-family="var(--font-mono)" fill="var(--diagram-mute)">\u00D7</text>`;
          } else if (fret === 0) {
            svg += `<circle cx="${x}" cy="${topPad - 14 + 4}" r="${dotRadius * 0.6}" fill="none" stroke="var(--diagram-open)" stroke-width="1.2"/>`;
          } else {
            const cy = topPad + (fret - 0.5) * fretSpacing;
            svg += `<circle cx="${x}" cy="${cy}" r="${dotRadius}" fill="var(--diagram-dot)"/>`;
          }
        }

        svg += `</svg>`;
        return svg;
      }

      return { render };
    })();


    /* ═══════════════════════════════════════════════════════════════
       6. CHORD GRID RENDERER
       ═══════════════════════════════════════════════════════════════ */
    const ChordGrid = (() => {
      const gridEl = document.getElementById('chordGrid');

      function render() {
        const { rootPc, scaleType } = AppState.get();
        const degrees = MusicTheory.buildGrid(rootPc, scaleType);

        let html = '';

        html += `<div class="grid-header" style="background:var(--paper);"></div>`;
        degrees.forEach(d => {
          html += `<div class="grid-header"><span class="roman">${d.roman}</span><span class="note-name">${d.note}</span></div>`;
        });

        const rows = [
          ['sus2', 'sus2'],
          ['Triad', 'triad'],
          ['sus4', 'sus4'],
          ['7th', 'seventh'],
        ];

        rows.forEach(([label, key]) => {
          const isTriad = key === 'triad';
          html += `<div class="row-label">${label}</div>`;

          degrees.forEach(d => {
            let quality = null;
            let isEmpty = false;

            if (key === 'sus2') {
              quality = d.sus2;
              isEmpty = !quality;
            } else if (key === 'sus4') {
              quality = d.sus4;
              isEmpty = !quality;
            } else if (key === 'triad') {
              quality = d.triad;
            } else if (key === 'seventh') {
              quality = d.seventh;
            }

            if (isEmpty) {
              html += `<div class="chord-cell empty ${isTriad ? 'triad-row' : ''}"><span class="cell-name">\u2014</span></div>`;
            } else {
              const suffix = MusicTheory.chordSuffix(quality);
              const name = d.note + suffix;
              html += `<div class="chord-cell ${isTriad ? 'triad-row' : ''}" data-degree="${d.degree}" data-quality="${quality}" data-pc="${d.pc}" data-name="${name}"><span class="cell-name">${name}</span></div>`;
            }
          });
        });

        gridEl.innerHTML = html;
        updateActiveHighlight();
      }

      function updateActiveHighlight() {
        const { activeChord } = AppState.get();
        gridEl.querySelectorAll('.chord-cell').forEach(cell => {
          cell.classList.remove('active');
          if (activeChord && cell.dataset.name === activeChord.name && cell.dataset.quality === activeChord.quality) {
            cell.classList.add('active');
          }
        });
      }

      gridEl.addEventListener('click', (e) => {
        const cell = e.target.closest('.chord-cell:not(.empty)');
        if (!cell) return;

        const quality = cell.dataset.quality;
        const pc = parseInt(cell.dataset.pc);
        const name = cell.dataset.name;
        const degree = parseInt(cell.dataset.degree);

        const frets = VoicingEngine.getVoicing(quality, pc);
        if (!frets) return;

        const midi = VoicingEngine.fretsToMidi(frets);
        const chord = { degree, quality, name, frets, midi, pc };

        AppState.set({ activeChord: chord });

        AudioEngine.strumChord(midi);
      });

      return { render, updateActiveHighlight };
    })();


    /* ═══════════════════════════════════════════════════════════════
       7. DIAGRAM DISPLAY
       ═══════════════════════════════════════════════════════════════ */
    const DiagramDisplay = (() => {
      const section = document.getElementById('diagramSection');
      const nameEl = document.getElementById('diagramName');
      const qualityEl = document.getElementById('diagramQuality');
      const svgEl = document.getElementById('diagramSvg');
      const notesEl = document.getElementById('diagramNotes');
      const addBtn = document.getElementById('addToProgression');

      function update(state) {
        const { activeChord } = state;
        if (!activeChord) {
          section.classList.remove('visible');
          return;
        }

        section.classList.add('visible');
        nameEl.textContent = activeChord.name;
        qualityEl.textContent = activeChord.quality;
        svgEl.innerHTML = ChordDiagram.render(activeChord.frets);

        const midi = activeChord.midi;
        const noteNames = midi
          .filter(n => n !== null)
          .map(n => VoicingEngine.midiToNoteName(n));
        notesEl.textContent = noteNames.join(' \u2013 ');
      }

      addBtn.addEventListener('click', () => {
        const { activeChord, progression } = AppState.get();
        if (!activeChord) return;
        const { name, quality, frets, midi, pc } = activeChord;
        AppState.set({ progression: [...progression, { name, quality, frets, midi, pc }] });
      });

      return { update };
    })();


    /* ═══════════════════════════════════════════════════════════════
       8. PROGRESSION BUILDER
       ═══════════════════════════════════════════════════════════════ */
    const ProgressionBuilder = (() => {
      const strip = document.getElementById('progressionStrip');
      const playBtn = document.getElementById('playBtn');
      const stopBtn = document.getElementById('stopBtn');
      const clearBtn = document.getElementById('clearBtn');
      const bpmSlider = document.getElementById('bpmSlider');
      const bpmLabel = document.getElementById('bpmLabel');
      const timeSigSelect = document.getElementById('timeSigSelect');
      const playTypeSelect = document.getElementById('playTypeSelect');
      const loopToggle = document.getElementById('loopToggle');
      const metronomeToggle = document.getElementById('metronomeToggle');

      let playbackIndex = -1;
      let scheduledEvents = [];

      let dragState = null;
      let suppressClick = false;

      function getTimeSigConfig(timeSig) {
        switch (timeSig) {
          case '3/4': return { toneTimeSig: 3, beatsPerBar: 3, beatDuration: '4n' };
          case '6/8': return { toneTimeSig: [6, 8], beatsPerBar: 6, beatDuration: '8n' };
          default:    return { toneTimeSig: 4, beatsPerBar: 4, beatDuration: '4n' };
        }
      }

      function beatTime(bar, beatIdx, timeSig) {
        if (timeSig === '6/8') {
          const qBeat = Math.floor(beatIdx / 2);
          const sub = (beatIdx % 2) * 2;
          return `${bar}:${qBeat}:${sub}`;
        }
        return `${bar}:${beatIdx}:0`;
      }

      function getArpeggioPattern(midiNotes, timeSig) {
        const notes = midiNotes.filter(n => n !== null).sort((a, b) => a - b);
        if (notes.length === 0) return [];
        const n = notes.length;
        const bass = notes[0];
        const top = notes[n - 1];
        const mid = notes[Math.floor(n / 2)];
        const lo = notes[Math.floor(n / 3)];
        const hi = notes[Math.floor(2 * n / 3)];

        switch (timeSig) {
          case '3/4': return [bass, mid, top];
          case '6/8': return [bass, lo, mid, bass, hi, top];
          default:    return [bass, mid, top, mid];
        }
      }

      function renderStrip() {
        const { progression, isPlaying } = AppState.get();

        if (progression.length === 0) {
          strip.innerHTML = '';
          strip.classList.add('empty-state');
          playBtn.disabled = true;
          stopBtn.disabled = true;
          clearBtn.disabled = true;
          return;
        }

        strip.classList.remove('empty-state');
        playBtn.disabled = isPlaying;
        stopBtn.disabled = !isPlaying;
        clearBtn.disabled = false;

        let html = '';
        progression.forEach((chord, i) => {
          const playing = i === playbackIndex ? ' playing' : '';
          html += `<div class="chord-chip${playing}" data-index="${i}">
            <span>${chord.name}</span>
            <span class="chip-remove" data-remove="${i}">\u2715</span>
          </div>`;
        });
        strip.innerHTML = html;
      }

      // ─── Drag-and-drop helpers ───
      function getDropIndex(clientX, clientY) {
        const chips = [...strip.querySelectorAll('.chord-chip')];
        const n = chips.length;
        if (n === 0) return 0;

        for (let i = 0; i < n; i++) {
          const r = chips[i].getBoundingClientRect();
          const midX = r.left + r.width / 2;
          const midY = r.top + r.height / 2;
          if (Math.abs(clientY - midY) > r.height) continue;
          if (clientX < midX) return i;
        }
        return n;
      }

      function clearDropIndicator() {
        strip.querySelectorAll('.drop-before,.drop-after').forEach(el => {
          el.classList.remove('drop-before', 'drop-after');
        });
      }

      function showDropIndicator(dropIdx) {
        clearDropIndicator();
        if (!dragState) return;
        const dragIdx = dragState.index;
        if (dropIdx === dragIdx || dropIdx === dragIdx + 1) return;

        const chips = strip.querySelectorAll('.chord-chip');
        if (dropIdx < chips.length) {
          chips[dropIdx].classList.add('drop-before');
        } else if (chips.length > 0) {
          chips[chips.length - 1].classList.add('drop-after');
        }
      }

      function onPointerDown(e) {
        if (AppState.get().isPlaying) return;
        if (e.target.closest('.chip-remove')) return;
        const chip = e.target.closest('.chord-chip');
        if (!chip) return;

        const rect = chip.getBoundingClientRect();
        dragState = {
          index: parseInt(chip.dataset.index),
          startX: e.clientX,
          startY: e.clientY,
          offsetX: e.clientX - rect.left,
          offsetY: e.clientY - rect.top,
          chip,
          ghost: null,
          active: false,
          dropIndex: parseInt(chip.dataset.index),
        };

        chip.setPointerCapture(e.pointerId);
        chip.addEventListener('pointermove', onPointerMove);
        chip.addEventListener('pointerup', onPointerUp);
        chip.addEventListener('lostpointercapture', onPointerUp);
      }

      function onPointerMove(e) {
        if (!dragState) return;

        const dx = e.clientX - dragState.startX;
        const dy = e.clientY - dragState.startY;

        if (!dragState.active) {
          if (Math.abs(dx) + Math.abs(dy) < 8) return;
          dragState.active = true;

          const ghost = document.createElement('div');
          ghost.className = 'drag-ghost';
          ghost.textContent = AppState.get().progression[dragState.index].name;
          document.body.appendChild(ghost);
          dragState.ghost = ghost;

          dragState.chip.classList.add('dragging');
        }

        dragState.ghost.style.left = (e.clientX - dragState.offsetX) + 'px';
        dragState.ghost.style.top = (e.clientY - dragState.offsetY) + 'px';

        const dropIdx = getDropIndex(e.clientX, e.clientY);
        dragState.dropIndex = dropIdx;
        showDropIndicator(dropIdx);
      }

      function onPointerUp(e) {
        if (!dragState) return;

        const ds = dragState;
        ds.chip.removeEventListener('pointermove', onPointerMove);
        ds.chip.removeEventListener('pointerup', onPointerUp);
        ds.chip.removeEventListener('lostpointercapture', onPointerUp);

        if (ds.active) {
          ds.ghost.remove();
          ds.chip.classList.remove('dragging');
          clearDropIndicator();
          suppressClick = true;

          const from = ds.index;
          const to = ds.dropIndex;
          if (to !== from && to !== from + 1) {
            const { progression } = AppState.get();
            const newProg = [...progression];
            const [moved] = newProg.splice(from, 1);
            const insertAt = to > from ? to - 1 : to;
            newProg.splice(insertAt, 0, moved);
            AppState.set({ progression: newProg });
          }
        }

        dragState = null;
      }

      strip.addEventListener('pointerdown', onPointerDown);

      strip.addEventListener('click', (e) => {
        if (suppressClick) { suppressClick = false; return; }

        const removeBtn = e.target.closest('.chip-remove');
        if (removeBtn) {
          e.stopPropagation();
          const idx = parseInt(removeBtn.dataset.remove);
          const { progression } = AppState.get();
          const newProg = [...progression];
          newProg.splice(idx, 1);
          AppState.set({ progression: newProg });
          return;
        }

        const chip = e.target.closest('.chord-chip');
        if (chip && !AppState.get().isPlaying) {
          const idx = parseInt(chip.dataset.index);
          const chord = AppState.get().progression[idx];
          if (chord) {
            AudioEngine.strumChord(chord.midi);
          }
        }
      });

      bpmSlider.addEventListener('input', () => {
        const bpm = parseInt(bpmSlider.value);
        bpmLabel.textContent = bpm + ' bpm';
        AppState.set({ bpm });
        if (AppState.get().isPlaying) {
          Tone.Transport.bpm.value = bpm;
        }
      });

      timeSigSelect.addEventListener('change', () => {
        AppState.set({ timeSig: timeSigSelect.value });
        if (AppState.get().isPlaying) { startPlayback(); }
      });

      playTypeSelect.addEventListener('change', () => {
        AppState.set({ playType: playTypeSelect.value });
        if (AppState.get().isPlaying) { startPlayback(); }
      });

      loopToggle.addEventListener('click', () => {
        const newLoop = !AppState.get().loop;
        AppState.set({ loop: newLoop });
        loopToggle.textContent = newLoop ? 'On' : 'Off';
        loopToggle.classList.toggle('active', newLoop);
        if (AppState.get().isPlaying) {
          Tone.Transport.loop = newLoop;
        }
      });

      metronomeToggle.addEventListener('click', () => {
        const newMet = !AppState.get().metronome;
        AppState.set({ metronome: newMet });
        metronomeToggle.textContent = newMet ? 'On' : 'Off';
        metronomeToggle.classList.toggle('active', newMet);
        if (AppState.get().isPlaying) { startPlayback(); }
      });

      async function startPlayback() {
        const { progression, bpm, timeSig, playType, loop, metronome } = AppState.get();
        if (progression.length === 0) return;

        await AudioEngine.ensureReady();

        Tone.Transport.stop();
        Tone.Transport.cancel();
        scheduledEvents = [];
        playbackIndex = -1;

        AppState.set({ isPlaying: true });

        const config = getTimeSigConfig(timeSig);
        Tone.Transport.bpm.value = bpm;
        Tone.Transport.timeSignature = config.toneTimeSig;
        Tone.Transport.position = 0;

        const totalBars = progression.length;

        Tone.Transport.loop = loop;
        if (loop) {
          Tone.Transport.loopStart = '0:0:0';
          Tone.Transport.loopEnd = `${totalBars}:0:0`;
        }

        progression.forEach((chord, bar) => {
          if (playType === 'arpeggio') {
            const pattern = getArpeggioPattern(chord.midi, timeSig);
            pattern.forEach((midi, beatIdx) => {
              const time = beatTime(bar, beatIdx, timeSig);
              const eventId = Tone.Transport.schedule((t) => {
                const t0 = t - 0.035;
                AudioEngine.getSampler().triggerAttackRelease(
                  VoicingEngine.midiToNoteName(midi), config.beatDuration, t0
                );
                if (beatIdx === 0) {
                  Tone.Draw.schedule(() => {
                    playbackIndex = bar;
                    renderStrip();
                  }, t);
                }
              }, time);
              scheduledEvents.push(eventId);
            });
          } else {
            const eventId = Tone.Transport.schedule((t) => {
              AudioEngine.scheduleChord(chord.midi, t);
              Tone.Draw.schedule(() => {
                playbackIndex = bar;
                renderStrip();
              }, t);
            }, `${bar}:0:0`);
            scheduledEvents.push(eventId);
          }
        });

        if (metronome) {
          for (let bar = 0; bar < totalBars; bar++) {
            for (let beatIdx = 0; beatIdx < config.beatsPerBar; beatIdx++) {
              const accent = beatIdx === 0 || (timeSig === '6/8' && beatIdx === 3);
              const time = beatTime(bar, beatIdx, timeSig);
              const eventId = Tone.Transport.schedule((t) => {
                AudioEngine.scheduleClick(t, accent);
              }, time);
              scheduledEvents.push(eventId);
            }
          }
        }

        if (!loop) {
          const stopEvent = Tone.Transport.schedule((t) => {
            Tone.Draw.schedule(() => {
              stopPlayback();
            }, t);
          }, `${totalBars}:0:0`);
          scheduledEvents.push(stopEvent);
        }

        Tone.Transport.start();
      }

      playBtn.addEventListener('click', () => { startPlayback(); });
      stopBtn.addEventListener('click', () => { stopPlayback(); });

      function stopPlayback() {
        if (Tone && Tone.Transport) {
          Tone.Transport.stop();
          Tone.Transport.cancel();
          Tone.Transport.loop = false;
        }
        scheduledEvents = [];
        playbackIndex = -1;
        AppState.set({ isPlaying: false });
      }

      clearBtn.addEventListener('click', () => {
        stopPlayback();
        AppState.set({ progression: [], activeChord: null });
      });

      return { renderStrip, stopPlayback };
    })();


    /* ═══════════════════════════════════════════════════════════════
       8b. GENERATE TRACK (AI Backing Track) + Credits
       ═══════════════════════════════════════════════════════════════ */
    const GenerateTrack = (() => {
      const generateBtn = document.getElementById('generateBtn');
      const styleInput = document.getElementById('styleInput');
      const generateOutput = document.getElementById('generateOutput');
      const generateStatusEl = document.getElementById('generateStatus');
      const generatePlayer = document.getElementById('generatePlayer');
      const downloadBtn = document.getElementById('downloadBtn');
      const creditBadge = document.getElementById('creditBadge');
      const buyCreditsPanel = document.getElementById('buyCreditsPanel');

      async function loadCredits() {
        if (!supabaseConfigured || !supabase) return;
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return;
        const { data, error } = await supabase
          .from('user_credits')
          .select('credits')
          .eq('user_id', user.id)
          .single();
        if (!error && data) {
          AppState.set({ userCredits: data.credits });
        }
      }

      function updateUI() {
        const { progression, generateStatus: status, generatedTrackUrl, userCredits } = AppState.get();
        const noCredits = userCredits !== null && userCredits <= 0;

        // Credit badge
        if (userCredits !== null) {
          creditBadge.style.display = '';
          creditBadge.textContent = `${userCredits} credit${userCredits !== 1 ? 's' : ''}`;
          creditBadge.classList.toggle('low', userCredits <= 0);
        } else {
          creditBadge.style.display = 'none';
        }

        // Buy panel visibility
        buyCreditsPanel.classList.toggle('visible', noCredits);
        buyCreditsPanel.style.display = noCredits ? '' : 'none';

        // Generate button
        generateBtn.disabled = progression.length === 0 || status === 'generating' || noCredits;
        generateBtn.textContent = status === 'generating' ? 'Generating...' : 'Generate Track';

        generateOutput.classList.toggle('visible', status !== 'idle');

        generateStatusEl.classList.remove('active', 'error');
        if (status === 'generating') {
          generateStatusEl.textContent = 'Generating backing track...';
          generateStatusEl.classList.add('active');
        } else if (status === 'error') {
          // Keep the custom error text if already set
          if (!generateStatusEl.textContent || generateStatusEl.textContent === '') {
            generateStatusEl.textContent = 'Generation failed. Try again.';
          }
          generateStatusEl.classList.add('error');
        } else if (status === 'done') {
          generateStatusEl.textContent = 'Track ready';
        } else {
          generateStatusEl.textContent = '';
        }

        generatePlayer.classList.toggle('visible', status === 'done' && !!generatedTrackUrl);
        if (status === 'done' && generatedTrackUrl && generatePlayer.src !== generatedTrackUrl) {
          generatePlayer.src = generatedTrackUrl;
        }

        downloadBtn.classList.toggle('visible', status === 'done' && !!generatedTrackUrl);
        if (generatedTrackUrl) {
          downloadBtn.href = generatedTrackUrl;
        }
      }

      styleInput.addEventListener('input', () => {
        AppState.set({ generateStyle: styleInput.value });
      });

      generateBtn.addEventListener('click', async () => {
        const { progression, bpm, timeSig, generateStyle } = AppState.get();
        if (progression.length === 0) return;

        if (!supabaseConfigured || !supabase) {
          AppState.set({ generateStatus: 'error' });
          generateOutput.classList.add('visible');
          generateStatusEl.textContent = 'Supabase is not configured';
          generateStatusEl.classList.remove('active');
          generateStatusEl.classList.add('error');
          return;
        }

        // Check auth — getUser() forces a token refresh if expired
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
          AppState.set({ generateStatus: 'error' });
          generateOutput.classList.add('visible');
          generateStatusEl.textContent = 'Sign in with Google to generate tracks';
          generateStatusEl.classList.remove('active');
          generateStatusEl.classList.add('error');
          return;
        }

        // Get session with fresh access token (getUser above refreshes if expired)
        const { data: { session } } = await supabase.auth.getSession();
        if (!session?.access_token) {
          AppState.set({ generateStatus: 'error' });
          generateOutput.classList.add('visible');
          generateStatusEl.textContent = 'Session expired. Please sign in again.';
          generateStatusEl.classList.remove('active');
          generateStatusEl.classList.add('error');
          return;
        }

        AppState.set({ generateStatus: 'generating', generatedTrackUrl: null });

        const chords = progression.map(c => c.name).join(', ');

        try {
          // Use raw fetch with explicit JWT access token to avoid issues
          // with publishable key format in supabase.functions.invoke()
          const response = await fetch(
            `${supabaseUrl}/functions/v1/hyper-processor`,
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${session.access_token}`,
                'apikey': supabaseAnonKey,
              },
              body: JSON.stringify({
                chords,
                bpm,
                timeSig,
                style: generateStyle || 'acoustic backing track',
              }),
            }
          );

          // Handle 402 — no credits
          if (response.status === 402) {
            AppState.set({ generateStatus: 'error', userCredits: 0 });
            generateOutput.classList.add('visible');
            generateStatusEl.textContent = 'No credits remaining. Purchase credits to continue generating.';
            generateStatusEl.classList.remove('active');
            generateStatusEl.classList.add('error');
            return;
          }

          if (!response.ok) {
            const errBody = await response.text();
            console.error('Edge function error:', response.status, errBody);
            throw new Error(`HTTP ${response.status}: ${errBody}`);
          }

          const data = await response.json();
          AppState.set({
            generateStatus: 'done',
            generatedTrackUrl: data.audio_url,
            userCredits: data.credits_remaining ?? AppState.get().userCredits,
          });
        } catch (e) {
          console.error('Generate track error:', e);
          AppState.set({ generateStatus: 'error' });
          generateStatusEl.textContent = 'Generation failed. Try again.';
        }
      });

      // Buy credits button handlers
      document.querySelectorAll('.credit-pack-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const pack = btn.dataset.pack;
          if (!supabaseConfigured || !supabase) return;

          // getUser() forces a token refresh if expired
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) {
            generateStatusEl.textContent = 'Please sign in to purchase credits.';
            generateStatusEl.classList.add('error');
            generateOutput.classList.add('visible');
            return;
          }

          const { data: { session } } = await supabase.auth.getSession();
          if (!session?.access_token) {
            generateStatusEl.textContent = 'Session expired. Please sign in again.';
            generateStatusEl.classList.add('error');
            generateOutput.classList.add('visible');
            return;
          }

          btn.disabled = true;
          btn.textContent = 'Loading...';

          try {
            const res = await fetch(
              `${supabaseUrl}/functions/v1/create-checkout`,
              {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${session.access_token}`,
                  'apikey': supabaseAnonKey,
                },
                body: JSON.stringify({ pack }),
              }
            );

            if (!res.ok) {
              const err = await res.json();
              throw new Error(err.error || 'Checkout failed');
            }

            const { url } = await res.json();
            if (url) {
              window.location.href = url;
            }
          } catch (e) {
            console.error('Checkout error:', e);
            generateOutput.classList.add('visible');
            generateStatusEl.textContent = 'Failed to start checkout. Try again.';
            generateStatusEl.classList.add('error');
          } finally {
            btn.disabled = false;
            const labels = { starter: '10 credits \u2014 $4.99', pro: '30 credits \u2014 $9.99', studio: '100 credits \u2014 $24.99' };
            btn.textContent = labels[pack] || pack;
          }
        });
      });

      // Load credits on payment return
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('payment') === 'success') {
        // Short delay to let webhook process
        setTimeout(() => loadCredits(), 2000);
        // Clean URL
        const cleanUrl = window.location.pathname;
        window.history.replaceState({}, '', cleanUrl);
      }

      AppState.subscribe(updateUI);

      return { updateUI, loadCredits };
    })();


    /* ═══════════════════════════════════════════════════════════════
       9. APP ORCHESTRATOR
       ═══════════════════════════════════════════════════════════════ */
    const App = (() => {
      const rootButtonsEl = document.getElementById('rootButtons');
      const scaleSelectEl = document.getElementById('scaleSelect');
      const scaleLabelEl = document.getElementById('scaleLabel');

      function initRootButtons() {
        MusicTheory.NOTE_NAMES.forEach((note, i) => {
          const btn = document.createElement('button');
          btn.className = 'root-btn' + (i === 0 ? ' active' : '');
          btn.textContent = note;
          btn.dataset.pc = i;
          rootButtonsEl.appendChild(btn);
        });

        rootButtonsEl.addEventListener('click', (e) => {
          const btn = e.target.closest('.root-btn');
          if (!btn) return;
          rootButtonsEl.querySelectorAll('.root-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          AppState.set({ rootPc: parseInt(btn.dataset.pc), activeChord: null });
        });
      }

      function initScaleSelect() {
        Object.entries(MusicTheory.SCALE_GROUPS).forEach(([group, scales]) => {
          const optgroup = document.createElement('optgroup');
          optgroup.label = group;
          scales.forEach(name => {
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name;
            optgroup.appendChild(opt);
          });
          scaleSelectEl.appendChild(optgroup);
        });

        scaleSelectEl.addEventListener('change', () => {
          AppState.set({ scaleType: scaleSelectEl.value, activeChord: null });
        });
      }

      function updateScaleLabel() {
        const { rootPc, scaleType } = AppState.get();
        const rootName = MusicTheory.getRootName(rootPc);
        scaleLabelEl.textContent = rootName + ' ' + scaleType;
      }

      // State change handler
      AppState.subscribe((state) => {
        updateScaleLabel();
        ChordGrid.render();
        DiagramDisplay.update(state);
        ProgressionBuilder.renderStrip();
      });

      function init() {
        initRootButtons();
        initScaleSelect();

        // Initial render
        updateScaleLabel();
        ChordGrid.render();
        DiagramDisplay.update(AppState.get());
        ProgressionBuilder.renderStrip();
        GenerateTrack.updateUI();
        GenerateTrack.loadCredits();
      }

      return { init };
    })();

    // Boot the app
    App.init();

    // Register cleanup for View Transitions navigation
    cleanup = () => {
      if (Tone && Tone.Transport) {
        Tone.Transport.stop();
        Tone.Transport.cancel();
        Tone.Transport.loop = false;
      }
    };
  });
</script>
